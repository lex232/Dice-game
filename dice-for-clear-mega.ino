#define col1 13                                // Колонки
#define col2 12
#define col3 11
#define col4 10
#define col5 9
#define col6 8
#define col7 7
#define col8 6

#define row1 3                                // Ряды
#define row2 2
#define row3 1
#define row4 0
#define row5 A5
#define row6 A4
#define row7 A3
#define row8 A2

#define vibration 4                           // Контакт датчика угла

uint8_t rows[8] {row1, row2, row3, row4, row5, row6, row7, row8};    // Пины строк
uint8_t cols[8] {col1, col2, col3, col4, col5, col6, col7, col8};    // Пины колонок
uint8_t randomValue = 0;                                             // Переменная случайного значения
uint8_t readSensor = 0;                                              // Временное состояние считанного значения датчика угла
int valCrash = 0;                                                    // Счётчик изменений датчика угла
unsigned long realTime;                                              // Переменные времени для сброса датчика угла
unsigned long shakeTime;                                             // Время для задания эффектов
unsigned long eventTime;                                             // Время для задания действия кубика
uint8_t a;                                                          // Переменная для задания эффектов
uint8_t event;                                                       // Флаг для определения начала действия кубика


char indication[8][8];                                                // Массив для динамической индикации

const char one[8][8] = {
  {'0', '0', '0', '0', '0', '0', '0', '0'},                          // Пустой экран
  {'0', '0', '0', '0', '0', '0', '0', '0'},
  {'0', '0', '0', '0', '0', '0', '0', '0'},
  {'0', '0', '0', '1', '1', '0', '0', '0'},
  {'0', '0', '0', '1', '1', '0', '0', '0'},
  {'0', '0', '0', '0', '0', '0', '0', '0'},
  {'0', '0', '0', '0', '0', '0', '0', '0'},
  {'0', '0', '0', '0', '0', '0', '0', '0'}
};

const char two[8][8] = {
  {'0', '0', '0', '0', '0', '0', '0', '0'},                          // Пустой экран
  {'0', '1', '1', '0', '0', '0', '0', '0'},
  {'0', '1', '1', '0', '0', '0', '0', '0'},
  {'0', '0', '0', '0', '0', '0', '0', '0'},
  {'0', '0', '0', '0', '0', '0', '0', '0'},
  {'0', '0', '0', '0', '0', '1', '1', '0'},
  {'0', '0', '0', '0', '0', '1', '1', '0'},
  {'0', '0', '0', '0', '0', '0', '0', '0'}
};

const char three[8][8] = {
  {'1', '1', '0', '0', '0', '0', '0', '0'},                          // Пустой экран
  {'1', '1', '0', '0', '0', '0', '0', '0'},
  {'0', '0', '0', '0', '0', '0', '0', '0'},
  {'0', '0', '0', '1', '1', '0', '0', '0'},
  {'0', '0', '0', '1', '1', '0', '0', '0'},
  {'0', '0', '0', '0', '0', '0', '0', '0'},
  {'0', '0', '0', '0', '0', '0', '1', '1'},
  {'0', '0', '0', '0', '0', '0', '1', '1'}
};

const char four[8][8] = {
  {'0', '0', '0', '0', '0', '0', '0', '0'},                          // Пустой экран
  {'0', '1', '1', '0', '0', '1', '1', '0'},
  {'0', '1', '1', '0', '0', '1', '1', '0'},
  {'0', '0', '0', '0', '0', '0', '0', '0'},
  {'0', '0', '0', '0', '0', '0', '0', '0'},
  {'0', '1', '1', '0', '0', '1', '1', '0'},
  {'0', '1', '1', '0', '0', '1', '1', '0'},
  {'0', '0', '0', '0', '0', '0', '0', '0'}
};

const char five[8][8] = {
  {'1', '1', '0', '0', '0', '0', '1', '1'},                          // Пустой экран
  {'1', '1', '0', '0', '0', '0', '1', '1'},
  {'0', '0', '0', '0', '0', '0', '0', '0'},
  {'0', '0', '0', '1', '1', '0', '0', '0'},
  {'0', '0', '0', '1', '1', '0', '0', '0'},
  {'0', '0', '0', '0', '0', '0', '0', '0'},
  {'1', '1', '0', '0', '0', '0', '1', '1'},
  {'1', '1', '0', '0', '0', '0', '1', '1'}
};

const char six[8][8] = {
  {'0', '0', '0', '0', '0', '0', '0', '0'},                          // Единица
  {'1', '1', '0', '1', '1', '0', '1', '1'},
  {'1', '1', '0', '1', '1', '0', '1', '1'},
  {'0', '0', '0', '0', '0', '0', '0', '0'},
  {'0', '0', '0', '0', '0', '0', '0', '0'},
  {'1', '1', '0', '1', '1', '0', '1', '1'},
  {'1', '1', '0', '1', '1', '0', '1', '1'},
  {'0', '0', '0', '0', '0', '0', '0', '0'}
};

const char frame1[8][8] = {
  {'0', '0', '0', '0', '0', '0', '0', '1'},                          // Пустой экран
  {'1', '0', '0', '0', '0', '0', '0', '0'},
  {'0', '0', '0', '0', '0', '0', '0', '1'},
  {'1', '0', '0', '0', '0', '0', '0', '0'},
  {'0', '0', '0', '0', '0', '0', '0', '1'},
  {'1', '0', '0', '0', '0', '0', '0', '0'},
  {'0', '0', '0', '0', '0', '0', '0', '1'},
  {'1', '0', '0', '0', '0', '0', '0', '0'}
};

const char frame2[8][8] = {
  {'0', '0', '0', '0', '0', '0', '1', '0'},                          // Пустой экран
  {'0', '1', '0', '0', '0', '0', '0', '0'},
  {'0', '0', '0', '0', '0', '0', '1', '0'},
  {'0', '1', '0', '0', '0', '0', '0', '0'},
  {'0', '0', '0', '0', '0', '0', '1', '0'},
  {'0', '1', '0', '0', '0', '0', '0', '0'},
  {'0', '0', '0', '0', '0', '0', '1', '0'},
  {'0', '1', '0', '0', '0', '0', '0', '0'}
};

const char frame3[8][8] = {
  {'0', '0', '0', '0', '0', '1', '0', '0'},                          // Пустой экран
  {'0', '0', '1', '0', '0', '0', '0', '0'},
  {'0', '0', '0', '0', '0', '1', '0', '0'},
  {'0', '0', '1', '0', '0', '0', '0', '0'},
  {'0', '0', '0', '0', '0', '1', '0', '0'},
  {'0', '0', '1', '0', '0', '0', '0', '0'},
  {'0', '0', '0', '0', '0', '1', '0', '0'},
  {'0', '0', '1', '0', '0', '0', '0', '0'}
};

const char frame4[8][8] = {
  {'0', '0', '0', '0', '1', '0', '0', '0'},                          // Пустой экран
  {'0', '0', '0', '1', '0', '0', '0', '0'},
  {'0', '0', '0', '0', '1', '0', '0', '0'},
  {'0', '0', '0', '1', '0', '0', '0', '0'},
  {'0', '0', '0', '0', '1', '0', '0', '0'},
  {'0', '0', '0', '1', '0', '0', '0', '0'},
  {'0', '0', '0', '0', '1', '0', '0', '0'},
  {'0', '0', '0', '1', '0', '0', '0', '0'}
};

const char frame5[8][8] = {
  {'0', '0', '0', '1', '0', '0', '0', '0'},                          // Пустой экран
  {'0', '0', '0', '0', '1', '0', '0', '0'},
  {'0', '0', '0', '1', '0', '0', '0', '0'},
  {'0', '0', '0', '0', '1', '0', '0', '0'},
  {'0', '0', '0', '1', '0', '0', '0', '0'},
  {'0', '0', '0', '0', '1', '0', '0', '0'},
  {'0', '0', '0', '1', '0', '0', '0', '0'},
  {'0', '0', '0', '0', '1', '0', '0', '0'}
};

const char frame6[8][8] = {
  {'0', '0', '1', '0', '0', '0', '0', '0'},                          // Пустой экран
  {'0', '0', '0', '0', '0', '1', '0', '0'},
  {'0', '0', '1', '0', '0', '0', '0', '0'},
  {'0', '0', '0', '0', '0', '1', '0', '0'},
  {'0', '0', '1', '0', '0', '0', '0', '0'},
  {'0', '0', '0', '0', '0', '1', '0', '0'},
  {'0', '0', '1', '0', '0', '0', '0', '0'},
  {'0', '0', '0', '0', '0', '1', '0', '0'}
};

const char frame7[8][8] = {
  {'0', '1', '0', '0', '0', '0', '0', '0'},                          // Пустой экран
  {'0', '0', '0', '0', '0', '0', '1', '0'},
  {'0', '1', '0', '0', '0', '0', '0', '0'},
  {'0', '0', '0', '0', '0', '0', '1', '0'},
  {'0', '1', '0', '0', '0', '0', '0', '0'},
  {'0', '0', '0', '0', '0', '0', '1', '0'},
  {'0', '1', '0', '0', '0', '0', '0', '0'},
  {'0', '0', '0', '0', '0', '0', '1', '0'}
};

const char frame8[8][8] = {
  {'1', '0', '0', '0', '0', '0', '0', '0'},                          // Пустой экран
  {'0', '0', '0', '0', '0', '0', '0', '1'},
  {'1', '0', '0', '0', '0', '0', '0', '0'},
  {'0', '0', '0', '0', '0', '0', '0', '1'},
  {'1', '0', '0', '0', '0', '0', '0', '0'},
  {'0', '0', '0', '0', '0', '0', '0', '1'},
  {'1', '0', '0', '0', '0', '0', '0', '0'},
  {'0', '0', '0', '0', '0', '0', '0', '1'}
};



void setup()
{



  for (int i = 0; i < 8; ++i) {
    pinMode(rows[i], OUTPUT);                 // Инициализируем пины строк на выход
    pinMode(cols[i], OUTPUT);                 // Инициализируем пины колонок на выход
  }

  pinMode(vibration, INPUT);                  // Вход датчика угла на вход
  //digitalWrite (vibration, HIGH);

  //random_value();                             // Задаём случайное значение
  reset_display();                            // Сбрасываем дисплей
}

void random_value ()
{
  randomSeed(analogRead(1));                  // Случайное значение с аналогового входа
  randomValue = random(1, 7);                 // Принимаем значение от 1 до 7

  for (int i = 0; i < 8; i++)                 // Цикл, который значения одного массива передаёт другому
  {
    for (int j = 0; j < 8; j++)
    {
      switch (randomValue) {
        case 1:
          indication[i][j] = one[i][j];       // В случае рандомного значения = 1, назначаем циклу indication значение массива one
          break;
        case 2:
          indication[i][j] = two[i][j];       // И т.д. для остальных значений
          break;
        case 3:
          indication[i][j] = three[i][j];
          break;
        case 4:
          indication[i][j] = four[i][j];
          break;
        case 5:
          indication[i][j] = five[i][j];
          break;
        case 6:
          indication[i][j] = six[i][j];
          break;
      }
    }
  }
}


void dynamic_indi()
{
  for (uint8_t c = 0; c < 8; c++)                        // Функция динамической индикации
  {
    for (uint8_t z = 0; z < 8; z++)
    {
      digitalWrite(cols[z], indication[c][z] - 48);      // Теперь назначаем колонкам значения из массива, для это строки и колонки
    }
    digitalWrite(rows[c], HIGH);                         // Устанавливаем строку в активное состояние
    delay(1);                                            // Пауза
    digitalWrite(rows[c], LOW);                          // Переводим строку в неактивное состояние
  }
}

void crash()
{
  if (digitalRead(vibration) == readSensor && event == 0)          // Если состояние датчика равно переменной состояния
  {
    readSensor = !readSensor;                        // Меняем переменную состояния на противоположное значение
    valCrash++;                                      // Инкрементируем счётчик трясок
    realTime = millis();

    if (valCrash > 12)                               // Если количество трясок более 20, то делаем действие
    {
      reset_display();
      eventTime = millis();
      realTime = millis();
      event = 1;
      valCrash = 0;                                  // Обнуляем счётчик трясок

      delay(30);
    }
  }
}

void resetCrash()
{
  if (millis() - realTime > 7000) // Если время контроллера millis, больше переменной на 1000, то запускаем условие if
  {
    realTime = millis();        // Приравниваем переменную текущего времени к времени контроллера, чтобы через 1000мс опять сработал наш цикл.
    valCrash = 0;
    reset_display();
  }
}

void reset_display()
{
  for (int i = 0; i < 8; i++)
  {
    for (int j = 0; j < 8; j++)
    {
      indication[i][j] = 48;
    }
  }
}

void shaking()
{
  if (millis() - shakeTime > 80)            // Функция
  {
  if (a>7)
  {
    a=0;
  }  
      for (int i = 0; i < 8; i++)                 // Цикл, который значения одного массива передаёт другому
      {
        for (int j = 0; j < 8; j++)
        {
          switch (a) {
            case 0:
              indication[i][j] = frame1[i][j];       // В случае рандомного значения = 1, назначаем циклу indication значение массива one
              break;
            case 1:
              indication[i][j] = frame2[i][j];       // И т.д. для остальных значений
              break;
            case 2:
              indication[i][j] = frame3[i][j];
              break;
            case 3:
              indication[i][j] = frame4[i][j];
              break;
            case 4:
              indication[i][j] = frame5[i][j];
              break;
            case 5:
              indication[i][j] = frame6[i][j];
              break;
            case 6:
              indication[i][j] = frame7[i][j];
              break;
            case 7:
              indication[i][j] = frame8[i][j];
              break;
          }
        }
      }
    a++;
    shakeTime = millis();
  }
}


void loop()
{
  //shaking();
  if (event == 1)
  {
    shaking();
  }
  if (millis() - eventTime >= 1500 && event == 1)
  {
    event = 0;
    reset_display();
    random_value();
    eventTime = millis();

  }
  resetCrash();
  crash();
  dynamic_indi();                                     // Динамическая индикация всегда должна быть активна
}
